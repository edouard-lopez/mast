#!/usr/bin/env bash
### BEGIN INIT INFO
# Provides:          mast
# Required-Start:    $network $remote_fs $syslog
# Required-Stop:     $network $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Daemon to manage multiple auto-ssh tunnels
# Description:       Daemon to manage multiple auto-ssh tunnels
### END INIT INFO

# Author: Édouard Lopez <srv+mast@edouard-lopez.com>

# Copyright 2014 - Édouard Lopez - http://edouard-lopez.com/
#
# This script is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
#
# This script is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details at http://www.gnu.org/licenses/.

# see: http://surniaulula.com/2012/12/10/autossh-startup-script-for-multiple-tunnels/
# Exit script if you try to use an uninitialised variable.
# @alias: set -u
# set -o nounset
# Exit script if any statement returns a non-true return value.
# @alias: set -e
# set -o errexit

# Import function library
source /lib/lsb/init-functions

RETVAL=0 # default return value
NAME=mast
autossh="$(which autossh)"
# template name for log file
LOG_DIR="/var/log/$NAME"
# SSH tunnel configuration directory (a file per host)
CONFIG_DIR="/etc/$NAME"
PID_DIR="/var/run/$NAME"

# Create PID directory missing
[[ ! -d $PID_DIR ]] && mkdir -p /var/run/"$NAME"
[[ ! -d /var/lock/"$NAME" ]] && mkdir -p /var/lock/"$NAME"

# Constants
abort_status=1 # used in 'return'

# debug mode (need to `export DEBUG='true'` and run as `sudo -E`, see installation.md)
[[ -n $DEBUG ]] && set -x

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#                                                    STDOUT FORMATTING
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Styling function
# formatting
_underline_="$(tput sgr 0 1)"	# Underline
_bold_="$(tput bold)"			# Bold
_reset_="$(tput sgr0)"			# Reset
# coloring
_info_="$(tput setaf 6)"		# blue/information
_warning_="$(tput setaf 3)"	# yellow/warning
_error_="$(tput setaf 1)"		# red/error
_log_="$(tput setaf 7)"			# value/white
_debug_="$(tput setaf 7)"			# value/white
_value_="$(tput setaf 5)"		# value/purple
_valid_="$(tput setaf 2)"		# valid/green
# helpers
_underline()	{ printf "${_underline_}%s${_reset_}" "$*"; } 			# style text as underline
_bold()			{ printf "${_bold_}%s${_reset_}" "$*"; } 				# style text as bold
_info()			{ printf "${_info_}%s${_reset_}" "$*"; } 				# style text as info
_log()			{ printf "${_log_}%s${_reset_}" "$*"; } 				# style text as log
_debug()		{ printf "${_debug_}%s${_reset_}" "$*"; } 				# style text as debug
_warning()		{ printf "${_warning_}%s${_reset_}" "$*"; } 			# style text as warning
_error()			{ printf "${_bold_}${_error_}%s${_reset_}" "$*"; } 	# style text as error
_value()		{ printf "${_value_}%s${_reset_}" "$*"; } 				# style text as value
_valid()			{ printf "${_valid_}%s${_reset_}" "$*"; } 				# style text as valid

# Print message helper
function feedback() {
	what="$1"
	status="$2"
	todo="$3"
	# cfname="$4"

	printf "\t%-48s%s\t%s\n" \
		"$(_info "$what")" \
		"$(_error "$status")" \
		"$(_debug "$todo")" \
	1>&2 | _log-to "$cfname"
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#                                                        UTILITIES
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Log file path for given config
# @param {string} config name
function _log-file() {
	if [[ -z "$1" ]]; then
		feedback "configuration name"  "$(_warning "required")"  "no configuration's name provided" 1>&2
		exit 1
	else
		echo "$LOG_DIR/$NAME-$1.log"
	fi
}


# Log piped message to stdout and in given config log file.
# @param:	{string} 	$1	configuration filename.
function _log-to() {
	if [[ -z "$1" ]]; then
		# do NOT refactor or get a fork bomb :D!
		printf "\t%s\t%s\t%s\n" \
			"$(_value "configuration name")" \
			"$(_warning "required")" \
			"$(_debug "no configuration's name provided")" \
		1>&2
		exit 1
	fi
	local cfname="$1"
	shift; read msg

	# print to stdout
	printf "%s\n" "$msg"

	# print to log file
	printf "[%s] %s\n" "$(_info "${FUNCNAME[1]}")" "$msg" >> "$(_log-file  "$cfname")"

	# open privileges to www-data
	chown www-data "$(_log-file  "$cfname")"
	chmod u=rwx,g=rwx "$(_log-file  "$cfname")"
}


# Make sure we have a config file
# @param:	{string}	$config		configuration filepath.
# @inherit:		{string} 	$cfname	configuration filename.
function check_config_file_exists() {
	local config="$CONFIG_DIR/$1"

	if [[ ! -f "$config" ]]; then
		feedback "$cfname"  "missing"  "no configuration file in $CONFIG_DIR"
		return $abort_status
	fi
}


# Make sure all arguments/variables have been defined in config
# @inherit:	{string} 	$cfname		configuration filename.
function check_tunnel_config() {
	sshArguments=( # list of required variables
		ServerAliveInterval ServerAliveCountMax StrictHostKeyChecking
		LocalUser IdentityFile RemoteUser RemoteHost RemotePort
		BandwidthLimitation UploadLimit DownloadLimit
	)

	for var in "${sshArguments[@]}"; do
		if [[ -z ${!var} ]]; then # test if each config's variable is empty (e.g. $ServerAliveInterval content)
			feedback "$var"  "undefined"  "no value in $CONFIG_DIR/$cfname"
			return $abort_status
		fi
	done
}


# We need at least 1 forward rule to be able to start
# @inherit:	{string} 	$cfname		configuration filename.
# @inherit:	{array}	$ForwardPort	list of SSH forwarding rules.
function check_ssh_forward_rules() {
	# workaround the lack of ${#ForwardPort[@]} support, no logical explaination
	for f in "${ForwardPort[@]}"; do (( rule_count++)); done

	# if (( ${#ForwardPort[@]} == 0 )); then
	if (( rule_count == 0 )); then
		feedback "ForwardPort array"  "empty"  "no value in $CONFIG_DIR/$cfname"
		return $abort_status
	fi

	for fwd in "${ForwardPort[@]}"; do
		fwd="${fwd%%#*}"
		case "$fwd" in
			D\ *:*|R\ *:*:*:*|L\ *:*:*:*)
				forward_list+="-$fwd "
			;;
			*)
				feedback "$cfname"  "mal-formed"  "format $(_value "$fwd") isn't correct"
				return $abort_status
			;;
		esac
	done
}


# Check if pidfile already exists -- don't start another instance if pidfile exists
# @inherit:	{string} 	$cfname	configuration filename.
# @inherit:	{string} 	$pidfile		PID file for host.
function check_no_pid_exists() {
	# Define the pidfile variable for autossh (created by autossh)
	export AUTOSSH_PIDFILE="$pidfile"
	if [[ -e $AUTOSSH_PIDFILE ]]; then
		pidfile="$(_value "$AUTOSSH_PIDFILE")"
		feedback "$cfname"  "forbidden"  "service already started (PID's file exists)"
		return $abort_status
	fi
}


# Before switching-users, make sure pidfile is created and user has write permission
# @inherit:	{string} 	$cfname	configuration filename.
function create_pid() {
	touch "$AUTOSSH_PIDFILE"
	chown "$LocalUser" "$AUTOSSH_PIDFILE"

	# check to make sure pidfile was created
	if [[ ! -f $AUTOSSH_PIDFILE ]]; then
		feedback "$cfname's PID creation"  "aborted"  ""
		return $abort_status
	fi
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#                                              START | STOP | RESTART | STATUS
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Start the service
# @param:	{string}	$config		configuration filepath.
function start() {
	local cfname="${1:-undef}"
	local config="$CONFIG_DIR/$cfname"
	local pidfile="$PID_DIR/$cfname.pid"
	local forward_list=""

	# abort start if one of the following fail
	check_config_file_exists "$cfname" && source "$config"    || return $abort_status
	check_tunnel_config                                                        || return $abort_status
	export ForwardPort
	check_ssh_forward_rules                                                || return $abort_status
	check_no_pid_exists                                                       || return $abort_status
	create_pid                                                                     || return $abort_status

	printf "Starting %s %s" "$(_info "$NAME")" "$(_value "$cfname")"

	# start autossh as the user defined in the config file
	# the pid file must be re-defined in the new environment
	su - "$LocalUser" -c "\
		export AUTOSSH_LOGLEVEL=7; \
		export AUTOSSH_DEBUG=true; \
		export AUTOSSH_PIDFILE=\"$AUTOSSH_PIDFILE\"; \
		export AUTOSSH_PORT=0; \
		export AUTOSSH_LOGFILE=\"$LOG_DIR/$NAME-$cfname.log\"; \
		$autossh -q -f -N -p $RemotePort \
			-i $IdentityFile \
			-v \
			-o ServerAliveInterval=$ServerAliveInterval \
			-o ServerAliveCountMax=$ServerAliveCountMax \
			-o StrictHostKeyChecking=$StrictHostKeyChecking \
			$forward_list $RemoteUser@$RemoteHost"

	# fixme: We can't get a exit status so we wait ~15s before considering start failed
	max_latency=15;
	feedback "latency" "$(_warning processing)" "wait a maximum of ${max_latency}s before failing"
	i=0;
	while [[ ! -f $pidfile ]]; do printf "."; (( i > max_latency)) && break; (( i++)); done;

	if [[ -s $pidfile ]]; then
		touch /var/lock/"$NAME/$cfname"
		feedback "$cfname"  "$(_valid started)"  "pid $(cat "$AUTOSSH_PIDFILE")"
	else
		feedback "$cfname"  "failed"  "empty pid $pidfile"
		rm -f "$AUTOSSH_PIDFILE" "$pidfile"
	fi
}


function stop() {
	local cfname="${1:-undef}"
	local config="$CONFIG_DIR/$cfname"
	local pidfile="$PID_DIR/$cfname.pid"
	local autossh_pid='undef' # see below

	# if no config names (on the command-line), stop all autossh processes
	if [[ -z "$config" ]]; then
		printf "Stopping all %s: " "$(_info "$NAME")"
		kill "$autossh_pid"
		RETVAL=$?
		echo
		if (( RETVAL == 0 )); then
			rm -f /var/lock/"$NAME"/*
			rm -f "$PID_DIR"/*.pid
		fi
	else
		if [[ ! -f "$pidfile" ]]; then
			printf "%s %s: %s missing\n" "$NAME" "$cfname" "$pidfile" 1>&2 | _log-to "$cfname"
			return $abort_status
		else
			printf "Stopping %s %s\n" "$(_info "$NAME")" "$(_value "$cfname")"
			autossh_pid=$(cat "$pidfile")
			if [[ -s "$pidfile" ]]; then  # kill if size > 0
				rm -f "$pidfile"  # always remove pid
				kill "$autossh_pid"
			else
				rm -f "$pidfile"  # in case pidfile is empty
			fi
		fi
	fi
	return ${RETVAL:-0}
}


function status() {
	local cfname="${1:-undef}"
	local config="$CONFIG_DIR/$cfname"
	local pidfile="$PID_DIR/$cfname.pid"
	local autossh_pid='undef' # see below

	check_config_file_exists "$cfname" || return $abort_status

	if [[ -s $pidfile ]]; then
		autossh_pid=$(cat "$pidfile")
		# select (AutoSSH) parent process
		autossh_info="$(ps --pid "$autossh_pid" -o pid,user,%mem)"
		# select children processes
		ssh_info="$(ps --ppid "$autossh_pid")"

		feedback "${config}:autossh" 	"querying"  "$autossh_info"
		feedback "${config}:ssh"  		"querying"  "$ssh_info"
	else
		feedback "$cfname"  "off"  "service has not been started yet"
	fi

	return ${RETVAL:-0}
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#                                                    COMMAND & CONTROL
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#  List available configuration in $CONFIG_DIR
function list_config() {
	config_list=()
	for config in $CONFIG_DIR/*; do
		config_list=( "${config_list[@]}" "$(basename "$config")" )
	done
	echo "${config_list[@]}"
}


# Execute action on given configurations
# @param:	{array}	$@		list of configuration names
function iter_action_on_config() {
	local action="$1"; shift
	local cfname_list=( "$@" )

	for cfname in "${cfname_list[@]}"; do
		[[ $cfname == *template || -d "$CONFIG_DIR/$cfname" || ! -f "$CONFIG_DIR/$cfname" ]] && continue
		"$action" "$cfname";
	done
}


# save the action name, and shift the command-line array
# all remaining command-line arguments *should* be config names
action="$1"
shift

case "$action" in
start)
	# if no config is provided run all exisiting configs, otherwise only the specified
	if [[ -z "$1" ]]; then
		iter_action_on_config "$action" $(list_config)
	else
		iter_action_on_config "$action" "$@"
	fi
	;;
stop)
	# if no config is provided run all exisiting configs, otherwise only the specified
	if [[ -z "$1" ]]; then
		iter_action_on_config "$action" $(list_config)
	else
		iter_action_on_config "$action" "$@"
	fi
	;;
restart)
	# if no config is provided run all exisiting configs, otherwise only the specified
	iter_action_on_config "stop" "$@"
	iter_action_on_config "start" "$@"
	;;
status)
	# if no config is provided run all exisiting configs, otherwise only the specified
	if [[ -z "$1" ]]; then
		iter_action_on_config "$action" $(list_config)
		RETVAL=$?
	else
		iter_action_on_config "$action" "$@"
	fi
	;;
*)
	printf "Usage: %s {start|stop|restart|status} {config names...}\n" "$0"
	RETVAL=1
	;;
esac
exit $RETVAL