#!/usr/bin/env bash
### BEGIN INIT INFO
# Provides:          mast
# Required-Start:    $network $remote_fs $syslog
# Required-Stop:     $network $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Daemon to manage multiple auto-ssh tunnels
# Description:       Daemon to manage multiple auto-ssh tunnels
### END INIT INFO

# Author: Édouard Lopez <srv+mast@edouard-lopez.com>

# Copyright 2014 - Édouard Lopez - http://edouard-lopez.com/
#
# This script is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
#
# This script is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details at http://www.gnu.org/licenses/.

# see: http://surniaulula.com/2012/12/10/autossh-startup-script-for-multiple-tunnels/
# Exit script if you try to use an uninitialised variable.
# @alias: set -u
# set -o nounset
# Exit script if any statement returns a non-true return value.
# @alias: set -e
set -o errexit

# Import function library
source /lib/lsb/init-functions

RETVAL=0 # default return value
NAME=mast
autossh="$(which autossh)"
# template name for log file
LOG_DIR="/var/log/$NAME"
# SSH tunnel configuration directory (a file per host)
CONFIG_DIR="/etc/$NAME"

# Create PID directory missing
[[ ! -d /var/run/$NAME ]] && mkdir -p /var/run/"$NAME"
[[ ! -d /var/lock/"$NAME" ]] && mkdir -p /var/lock/"$NAME"


# Styling function
# formatting
_underline_="$(tput sgr 0 1)"	# Underline
_bold_="$(tput bold)"			# Bold
_reset_="$(tput sgr0)"			# Reset
# coloring
_info_="$(tput setaf 6)"		# blue/information
_warning_="$(tput setaf 3)"	# yellow/warning
_error_="$(tput setaf 1)"		# red/error
_log_="$(tput setaf 7)"			# value/white
_value_="$(tput setaf 5)"		# value/purple
_valid_="$(tput setaf 2)"		# valid/green
# helpers
_underline()	{ printf "${_underline_}%s${_reset_}" "$*"; } 			# style text as underline
_bold()			{ printf "${_bold_}%s${_reset_}" "$*"; } 				# style text as bold
_info()			{ printf "${_info_}%s${_reset_}" "$*"; } 				# style text as info
_log()			{ printf "${_log_}%s${_reset_}" "$*"; } 				# style text as info
_warning()		{ printf "${_warning_}%s${_reset_}" "$*"; } 			# style text as warning
_error()			{ printf "${_bold_}${_error_}%s${_reset_}" "$*"; } 	# style text as error
_value()		{ printf "${_value_}%s${_reset_}" "$*"; } 				# style text as value
_valid()			{ printf "${_valid_}%s${_reset_}" "$*"; } 				# style text as valid


# Log file path for given config
# @param {string} config name
_log-file() {
	if [[ -z "$1" ]]; then
		printf "You must give a %s!\n" "$(_warning "config name")" 1>&2
		exit 1
	else
		echo "$LOG_DIR/$NAME-$1.log"
	fi
}

# Log piped message to stdout and in given config log file.
# @param {string} config name
_log-to() {
	if [[ -z "$1" ]]; then
		printf "You must give a %s!\n" "$(_warning "config name")" 1>&2
		exit 1
	fi
	cfname="$1"
	shift; read msg

	# print to stdout
	printf "%s\n" "$msg"

	# print to log file
	printf "[%s] %s\n" "$(_info "${FUNCNAME[1]}")" "$msg" >> "$(_log-file  "$cfname")"

	# open privileges to www-data
	chown www-data "$(_log-file  "$cfname")"
	chmod u=rwx,g=rwx "$(_log-file  "$cfname")"
}


start() {
	config="$1"
	cfname="$(basename "$config")"
	forward_list=""

	# make sure we have a config file
	if [[ ! -f "$config" ]]; then
		printf "%s %s\n" "$cfname" "$(_error "doesn't exists")" 1>&2 | _log-to "$cfname"
		return 1
	fi

	source "$config"

	# make sure all arguments/variables have been defined in config
	sshArguments=(
		ServerAliveInterval ServerAliveCountMax StrictHostKeyChecking
		LocalUser IdentityFile RemoteUser RemoteHost RemotePort
		BandwidthLimitation UploadLimit DownloadLimit
	)
	for var in "${sshArguments[@]}"; do
	eval "
		if [[ -z \$$var ]]
		then
			printf \"%s: %s variable empty\\n\" \"$cfname\" \"$var\" 1>&2 | _log-to \"$cfname\"
			return 1
		fi
		"
	done

	if (( ${#ForwardPort[*]} == 0 )); then
		printf "%s: ForwardPort array empty\n" "$cfname" 1>&2 | _log-to "$cfname"
		return 1
	fi

	for fwd in "${ForwardPort[@]}"; do
		case "$fwd" in
			D\ *:*|R\ *:*:*:*|L\ *:*:*:*)
				forward_list+="-$fwd "
			;;
			*)
				printf "%s: %s format unknown\n" "$cfname" "$fwd" 1>&2 | _log-to "$cfname"
				return 1
			;;
		esac
	done

	# define the pidfile variable for autossh (created by autossh)
	# check if pidfile already exists -- don't start another instance if pidfile exists
	AUTOSSH_PIDFILE="/var/run/$NAME/$cfname.pid"
	if [[ -e $AUTOSSH_PIDFILE ]]; then
		printf "PID for %s %s (%s)\n" "$(_value "$cfname")" "$(_warning "already exists")" "$(_log "$AUTOSSH_PIDFILE")" 1>&2 | _log-to "$cfname"
		return 1
	fi

	printf "Starting %s %s: " "$NAME" "$cfname"

	# before switching-users, make sure pidfile is created and user has write permission
	touch "$AUTOSSH_PIDFILE"
	chown "$LocalUser" "$AUTOSSH_PIDFILE"

	# start autossh as the user defined in the config file
	# the pidfile must be re-defined in the new environment
	su - "$LocalUser" bash -c "
		AUTOSSH_PIDFILE=$AUTOSSH_PIDFILE;
		AUTOSSH_PORT=0;
		export AUTOSSH_PIDFILE AUTOSSH_PORT;
		$autossh -q -N -p $RemotePort \
		-i $IdentityFile \
		-o ServerAliveInterval=$ServerAliveInterval \
		-o ServerAliveCountMax=$ServerAliveCountMax \
		-o StrictHostKeyChecking=$StrictHostKeyChecking \
		$forward_list $RemoteUser@$RemoteHost -f;"

	# check to make sure pidfile was created
	if [[ ! -f $AUTOSSH_PIDFILE ]]; then
		printf "%s not created\n" "$(basename "$AUTOSSH_PIDFILE")" 1>&2 | _log-to "$cfname"
		return 1
	fi

	echo
	touch /var/lock/"$NAME"/"$cfname"
}


stop() {
	config="$1"
	# if no config names (on the command-line), stop all autossh processes
	if [[ -z "$config" ]]; then
		printf "Stopping all %s: " "$(_info "$NAME")"
		killproc "$autossh"
		RETVAL=$?
		echo
		if [[ $RETVAL -eq 0 ]]; then
			rm -f /var/lock/$NAME/"$cfname"
			rm -f /var/run/$NAME/*.pid
		fi
	else
		cfname="$(basename "$config")"
		pidfile="/var/run/$NAME/$cfname.pid"
		if [[ ! -f "$pidfile" ]]
		then
			printf "%s %s: %s missing\n" "$NAME" "$cfname" "$pidfile" 1>&2 | _log-to "$cfname"
			return 1
		else
			printf "Stopping %s %s: " "$NAME" "$cfname"
			killproc -p "/var/run/$NAME/$cfname.pid" "$NAME $cfname"
			RETVAL=$?
			echo
			[ $RETVAL -eq 0 ] && rm -f "/var/run/$NAME/$cfname.pid"
		fi
	fi
	return $RETVAL
}


# save the action name, and shift the command-line array
# all remaining command-line arguments *should* be config names
action="$1"
shift

case "$action" in
start)
	if [[ -z "$1" ]]; then
		# if no config names on the command-line, start all /etc/autossh/ configs found
		# for config in $(echo /etc/$NAME/${cfname:='*'})
		for config in /etc/$NAME/${cfname:='*'}; do
			[[ ! -f "$config" || -d "$config" || $config == "template" ]] && continue
			"$action" "$config";
		done
	else
		# start only the config files specified on the command-line
		for cfname in "$@"; do
			"$action" "/etc/$NAME/$cfname";
		done
	fi
	;;
stop)
	if [[ -z "$1" ]]; then
		# if no config names on the command-line, stop all autossh processes
		"$action"
	else
		# stop only the config files specified on the command-line
		for cfname in "$@"; do
			"$action" "/etc/$NAME/$cfname";
		done
	fi
	;;
restart)
	# re-execute this script, with the stop and start action names instead
	"$0" stop "$@"
	"$0" start "$@"
	;;
status)
	if [[ -z "$1" ]]; then
		# if no config names on the command-line, show all autossh pids
		status "$autossh"
		RETVAL=$?
	else
		# only show the status of config files specified on the command-line
		for cfname in "$@";
		do
			config="/etc/$NAME/$cfname"
			# if the config file is missing, printf an error message
			if [[ -f $config ]]
			then
				cfname="$(basename "$config")"
				pidfile="/var/run/$NAME/$cfname.pid"
				# if the pidfile is missing, printf an error message
				if [[ -f $pidfile ]]
				then
					status -p "$pidfile" "$NAME $cfname"
					RETVAL=$?
				else
					printf "%s missing\n" "$pidfile"
					RETVAL=1
				fi
			else
				printf "%s missing\n" "$config"
				RETVAL=1
			fi
		done
	fi
	;;
*)
	printf "Usage: %s {start|stop|restart|status} {config names...}\n" "$0"
	RETVAL=1
	;;
esac
exit $RETVAL