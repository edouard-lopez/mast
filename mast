#!/usr/bin/env bash
### BEGIN INIT INFO
# Provides:          mast
# Required-Start:    $network $remote_fs $syslog
# Required-Stop:     $network $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Daemon to manage multiple auto-ssh tunnels
# Description:       Daemon to manage multiple auto-ssh tunnels
### END INIT INFO

# Author: Édouard Lopez <srv+mast@edouard-lopez.com>

# Copyright 2014 - Édouard Lopez - http://edouard-lopez.com/
#
# This script is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
#
# This script is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details at http://www.gnu.org/licenses/.

# see: http://surniaulula.com/2012/12/10/autossh-startup-script-for-multiple-tunnels/
# Exit script if you try to use an uninitialised variable.
# @alias: set -u
# set -o nounset
# Exit script if any statement returns a non-true return value.
# @alias: set -e
set -o errexit

# Import function library
source /lib/lsb/init-functions

RETVAL=0 # default return value
NAME=mast
autossh="$(which autossh)"
# template name for log file
LOG_DIR="/var/log/$NAME"
# SSH tunnel configuration directory (a file per host)
CONFIG_DIR="/etc/$NAME"

# Create PID directory missing
[[ ! -d /var/run/$NAME ]] && mkdir -p /var/run/"$NAME"
[[ ! -d /var/lock/"$NAME" ]] && mkdir -p /var/lock/"$NAME"

# Constants
abort_status=1 # used in 'return'

# Styling function
# formatting
_underline_="$(tput sgr 0 1)"	# Underline
_bold_="$(tput bold)"			# Bold
_reset_="$(tput sgr0)"			# Reset
# coloring
_info_="$(tput setaf 6)"		# blue/information
_warning_="$(tput setaf 3)"	# yellow/warning
_error_="$(tput setaf 1)"		# red/error
_log_="$(tput setaf 7)"			# value/white
_debug_="$(tput setaf 7)"			# value/white
_value_="$(tput setaf 5)"		# value/purple
_valid_="$(tput setaf 2)"		# valid/green
# helpers
_underline()	{ printf "${_underline_}%s${_reset_}" "$*"; } 			# style text as underline
_bold()			{ printf "${_bold_}%s${_reset_}" "$*"; } 				# style text as bold
_info()			{ printf "${_info_}%s${_reset_}" "$*"; } 				# style text as info
_log()			{ printf "${_log_}%s${_reset_}" "$*"; } 				# style text as log
_debug()		{ printf "${_debug_}%s${_reset_}" "$*"; } 				# style text as debug
_warning()		{ printf "${_warning_}%s${_reset_}" "$*"; } 			# style text as warning
_error()			{ printf "${_bold_}${_error_}%s${_reset_}" "$*"; } 	# style text as error
_value()		{ printf "${_value_}%s${_reset_}" "$*"; } 				# style text as value
_valid()			{ printf "${_valid_}%s${_reset_}" "$*"; } 				# style text as valid
# Print message helper
feedback() {
	what="$1"
	status="$2"
	todo="$3"
	# cfname="$4"

	printf "\t%-48s%s\t%s\n" \
		"$(_info "$what")" \
		"$(_error "$status")" \
		"$(_debug "$todo")" \
	1>&2 | _log-to "$cfname"
}




# Log file path for given config
# @param {string} config name
_log-file() {
	if [[ -z "$1" ]]; then
		feedback "configuration name"  "$(_warning "required")"  "no configuration's name provided" 1>&2
		exit 1
	else
		echo "$LOG_DIR/$NAME-$1.log"
	fi
}

# Log piped message to stdout and in given config log file.
# @param:	{string} 	$1	configuration filename.
_log-to() {
	if [[ -z "$1" ]]; then
		# do NOT refactor or get a fork bomb :D!
		printf "\t%s\t%s\t%s\n" \
			"$(_value "configuration name")" \
			"$(_warning "required")" \
			"$(_debug "no configuration's name provided")" \
		1>&2
		exit 1
	fi
	cfname="$1"
	shift; read msg

	# print to stdout
	printf "%s\n" "$msg"

	# print to log file
	printf "[%s] %s\n" "$(_info "${FUNCNAME[1]}")" "$msg" >> "$(_log-file  "$cfname")"

	# open privileges to www-data
	chown www-data "$(_log-file  "$cfname")"
	chmod u=rwx,g=rwx "$(_log-file  "$cfname")"
}

# Make sure we have a config file
# @param:	{string}	$config		configuration filepath.
# @inherit:		{string} 	$cfname	configuration filename.
check_config_file_exists() {
	config="$1"

	if [[ ! -f "$config" ]]; then
		feedback "$cfname"  "missing"  "no configuration file in $CONFIG_DIR"
		return $abort_status
	fi
}


# Make sure all arguments/variables have been defined in config
# @inherit:		{string} 	$cfname		configuration filename.
check_tunnel_config() {
	sshArguments=( # list of required variables
		ServerAliveInterval ServerAliveCountMax StrictHostKeyChecking
		LocalUser IdentityFile RemoteUser RemoteHost RemotePort
		BandwidthLimitation UploadLimit DownloadLimit
	)

	for var in "${sshArguments[@]}"; do
		if [[ -z ${!var} ]]; then # test if each config's variable is empty (e.g. $ServerAliveInterval content)
			feedback "$var"  "undefined"  "no value in $CONFIG_DIR/$cfname"
			return $abort_status
		fi
	done
}


# We need at least 1 forward rule to be able to start
# @inherit:		{string} 	$cfname		configuration filename.
# @inherit:		{array}	$ForwardPort	list of SSH forwarding rules.
check_ssh_forward_rules() {
	# workaround the lack of ${#ForwardPort[@]} support, no logical explaination
	for f in "${ForwardPort[@]}"; do (( rule_count++)); done

	# if (( ${#ForwardPort[@]} == 0 )); then
	if (( rule_count == 0 )); then
		feedback "ForwardPort array"  "empty"  "no value in $CONFIG_DIR/$cfname."
		return $abort_status
	fi

	for fwd in "${ForwardPort[@]}"; do
		fwd="${fwd%%#*}"
		case "$fwd" in
			D\ *:*|R\ *:*:*:*|L\ *:*:*:*)
				forward_list+="-$fwd "
			;;
			*)
				feedback "$cfname"  "mal-formed"  "format $(_value "$fwd") isn't correct."
				return $abort_status
			;;
		esac
	done
}

# 	check if pidfile already exists -- don't start another instance if pidfile exists
# @inherit:	{string} 	$cfname	configuration filename.
# @inherit:	{string} 	$pidfile		PID file for host.
check_no_pid_exists() {
	# Define the pidfile variable for autossh (created by autossh)
	export AUTOSSH_PIDFILE="$pidfile"
	if [[ -e $AUTOSSH_PIDFILE ]]; then
		feedback "host PID"  "forbidden"  "PID already exists, stop service or remove $(_value "$AUTOSSH_PIDFILE")."
		return $abort_status
	fi
}


# Before switching-users, make sure pidfile is created and user has write permission
# @inherit:	{string} 	$cfname	configuration filename.
create_pid() {
	touch "$AUTOSSH_PIDFILE"
	chown "$LocalUser" "$AUTOSSH_PIDFILE"

	# check to make sure pidfile was created
	if [[ ! -f $AUTOSSH_PIDFILE ]]; then
		feedback "$cfname's PID creation"  "aborted"  ""
		return $abort_status
	fi
}


# Start the service
# @param:	{string}	$config		configuration filepath.
start() {
	config="$1"
	cfname="$(basename "$config")"
	pidfile="/var/run/$NAME/$cfname.pid"
	forward_list=""

	# abort start if one of the following fail
	check_config_file_exists "$config"	&& source "$config"	|| return $abort_status
	check_tunnel_config 							|| return $abort_status
	export ForwardPortq
	check_ssh_forward_rules		|| return $abort_status
	check_no_pid_exists							|| return $abort_status
	create_pid 												|| return $abort_status

	printf "Starting %s %s\n" "$(_info "$NAME")" "$(_value "$cfname")"

	# start autossh as the user defined in the config file
	# the pid file must be re-defined in the new environment
	su - "$LocalUser" -c "
		export AUTOSSH_PIDFILE=$AUTOSSH_PIDFILE; \
		export AUTOSSH_PORT=0; \
		export AUTOSSH_LOGFILE="$LOG_DIR/$NAME-$cfname.log"; \
		$autossh -q -f -N -p $RemotePort \
			-i $IdentityFile \
			-v \
			-o ServerAliveInterval=$ServerAliveInterval \
			-o ServerAliveCountMax=$ServerAliveCountMax \
			-o StrictHostKeyChecking=$StrictHostKeyChecking \
			$forward_list $RemoteUser@$RemoteHost &"

	touch /var/lock/"$NAME/$cfname"
}


stop() {
	config="$1"
	cfname="$(basename "$config")"
	pidfile="/var/run/$NAME/$cfname.pid"
	autossh_pid=$(cat "$pidfile")

	# if no config names (on the command-line), stop all autossh processes
	if [[ -z "$config" ]]; then
		printf "Stopping all %s: " "$(_info "$NAME")"
		kill "$autossh_pid"
		RETVAL=$?
		echo
		if (( RETVAL == 0 )); then
			rm -f /var/lock/"$NAME"/*
			rm -f /var/run/"$NAME"/*.pid
		fi
	else
		if [[ ! -f "$pidfile" ]]; then
			printf "%s %s: %s missing\n" "$NAME" "$cfname" "$pidfile" 1>&2 | _log-to "$cfname"
			return $abort_status
		else
			printf "Stopping %s %s\n" "$(_info "$NAME")" "$(_value "$cfname")"
			rm -f "$pidfile"  # always remove pid
			if [[ -s "$pidfile" ]]; then
				kill "$autossh_pid"  # kill if size > 0
			else
				rm -f "$pidfile"  # in case pidfile is empty
			fi
		fi
	fi
	return ${RETVAL:-0}
}


# save the action name, and shift the command-line array
# all remaining command-line arguments *should* be config names
action="$1"
shift

case "$action" in
start)
	if [[ -z "$1" ]]; then
		# if no config names on the command-line, start all /etc/autossh/ configs found
		# for config in $(echo /etc/$NAME/${cfname:='*'}); do
		for config in /etc/$NAME/${cfname:='*'}; do
			[[ $config == *template || -d "$config" || ! -f "$config" ]] && continue
			"$action" "$config";
		done
	else
		# start only the config files specified on the command-line
		for cfname in "$@"; do
			"$action" "/etc/$NAME/$cfname";
		done
	fi
	;;
stop)
	if [[ -z "$1" ]]; then
		# if no config names on the command-line, stop all autossh processes
		"$action"
	else
		# stop only the config files specified on the command-line
		for cfname in "$@"; do
			"$action" "/etc/$NAME/$cfname";
		done
	fi
	;;
restart)
	# re-execute this script, with the stop and start action names instead
	"$0" stop "$@"
	"$0" start "$@"
	;;
status)
	if [[ -z "$1" ]]; then
		# if no config names on the command-line, show all autossh pids
		status "$autossh"
		RETVAL=$?
	else
		# only show the status of config files specified on the command-line
		for cfname in "$@";
		do
			config="/etc/$NAME/$cfname"
			# if the config file is missing, printf an error message
			if [[ -f $config ]]
			then
				cfname="$(basename "$config")"
				pidfile="/var/run/$NAME/$cfname.pid"
				# if the pidfile is missing, printf an error message
				if [[ -f $pidfile ]]
				then
					status -p "$pidfile" "$NAME $cfname"
					RETVAL=$?
				else
					printf "%s missing\n" "$pidfile"
					RETVAL=1
				fi
			else
				printf "%s missing\n" "$config"
				RETVAL=1
			fi
		done
	fi
	;;
*)
	printf "Usage: %s {start|stop|restart|status} {config names...}\n" "$0"
	RETVAL=1
	;;
esac
exit $RETVAL